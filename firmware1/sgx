PRCTL(2)                                    Linux Programmer's Manual                                   PRCTL(2)

[1mNAME[0m
       prctl - operations on a process

[1mSYNOPSIS[0m
       [1m#include <sys/prctl.h>[0m

       [1mint prctl(int [4m[22moption[24m[1m, unsigned long [4m[22marg2[24m[1m, unsigned long [4m[22marg3[24m[1m,[0m
                 [1munsigned long [4m[22marg4[24m[1m, unsigned long [4m[22marg5[24m[1m);[0m

[1mDESCRIPTION[0m
       [1mprctl[22m()  is  called with a first argument describing what to do (with values defined in [4m<linux/prctl.h>[24m),
       and further arguments with a significance depending on the first one.  The first argument can be:

       [1mPR_CAP_AMBIENT [22m(since Linux 4.3)
              Reads or changes the ambient capability set, according to the value of [4marg2[24m, which must be one  of
              the following:

              [1mPR_CAP_AMBIENT_RAISE[0m
                     The  capability  specified  in  [4marg3[24m is added to the ambient set.  The specified capability
                     must already be present in both the permitted and the  inheritable  sets  of  the  process.
                     This operation is not permitted if the [1mSECBIT_NO_CAP_AMBIENT_RAISE [22msecurebit is set.

              [1mPR_CAP_AMBIENT_LOWER[0m
                     The capability specified in [4marg3[24m is removed from the ambient set.

              [1mPR_CAP_AMBIENT_IS_SET[0m
                     The  [1mprctl[22m(2) call returns 1 if the capability in [4marg3[24m is in the ambient set and 0 if it is
                     not.

              [1mPR_CAP_AMBIENT_CLEAR_ALL[0m
                     All capabilities will be removed from the ambient set.   This  operation  requires  setting
                     [4marg3[24m to zero.

              In all of the above operations, [4marg4[24m and [4marg5[24m must be specified as 0.

       [1mPR_CAPBSET_READ [22m(since Linux 2.6.25)
              Return  (as  the function result) 1 if the capability specified in [4marg2[24m is in the calling thread's
              capability bounding set, or 0 if it is not.  (The capability constants are defined in [4m<linux/capa‚Äê[0m
              [4mbility.h>[24m.)   The  capability bounding set dictates whether the process can receive the capability
              through a file's permitted capability set on a subsequent call to [1mexecve[22m(2).

              If the capability specified in [4marg2[24m is not valid, then the call fails with the error [1mEINVAL[22m.

       [1mPR_CAPBSET_DROP [22m(since Linux 2.6.25)
              If the calling thread has the [1mCAP_SETPCAP [22mcapability, then drop the capability specified  by  [4marg2[0m
              from  the  calling  thread's  capability  bounding  set.   Any children of the calling thread will
              inherit the newly reduced bounding set.

              The call fails with the error: [1mEPERM [22mif the calling thread does not have the  [1mCAP_SETPCAP[22m;  [1mEINVAL[0m
              if  [4marg2[24m  does not represent a valid capability; or [1mEINVAL [22mif file capabilities are not enabled in
              the kernel, in which case bounding sets are not supported.

       [1mPR_SET_CHILD_SUBREAPER [22m(since Linux 3.4)
              If [4marg2[24m is nonzero, set the "child subreaper" attribute of the calling process; if [4marg2[24m  is  zero,
              unset  the  attribute.  When a process is marked as a child subreaper, all of the children that it
              creates, and their descendants, will be marked as having a subreaper.  In effect, a subreaper ful‚Äê
              fills  the  role  of  [1minit[22m(1) for its descendant processes.  Upon termination of a process that is
              orphaned (i.e., its immediate parent has already terminated) and marked as having a subreaper, the
              nearest  still  living  ancestor subreaper will receive a [1mSIGCHLD [22msignal and be able to [1mwait[22m(2) on
              the process to discover its termination status.

       [1mPR_GET_CHILD_SUBREAPER [22m(since Linux 3.4)
              Return the "child subreaper" setting of the caller, in the location pointed to by [4m(int[24m [4m*)[24m [4marg2[24m.

       [1mPR_SET_DUMPABLE [22m(since Linux 2.3.20)
              Set the state of the "dumpable" flag, which determines whether core dumps  are  produced  for  the
              calling process upon delivery of a signal whose default behavior is to produce a core dump.

              In  kernels  up  to and including 2.6.12, [4marg2[24m must be either 0 ([1mSUID_DUMP_DISABLE[22m, process is not
              dumpable) or 1 ([1mSUID_DUMP_USER[22m, process is dumpable).  Between  kernels  2.6.13  and  2.6.17,  the
              value  2  was  also  permitted,  which  caused any binary which normally would not be dumped to be
              dumped readable by root only; for security reasons, this feature has been removed.  (See also  the
              description of [4m/proc/sys/fs/suid_dumpable[24m in [1mproc[22m(5).)

              Normally,  this flag is set to 1.  However, it is reset to the current value contained in the file
              [4m/proc/sys/fs/suid_dumpable[24m (which by default has the value 0), if any of the following  attributes
              of the process are changed by the operations listed below:

              *  The effective user or group ID is changed.

              *  The filesystem user or group ID is changed (see [1mcredentials[22m(7)).

              *  The  process's set of permitted capabilities (see [1mcapabilities[22m(7)) is changed such that its new
                 set of capabilities is not a subset of its previous set of capabilities.

              The operations that may trigger changes to the dumpable flag include:

              *  execution ([1mexecve[22m(2)) of a set-user-ID or set-group-ID program, or a program that has capabili‚Äê
                 ties (see [1mcapabilities[22m(7));

              *  [1mcapset[22m(2); and

              *  system  calls that change process credentials ([1msetuid[22m(2) [1msetgid[22m(2), [1msetresuid[22m(2), [1msetresgid[22m(2),
                 [1msetgroups[22m(2), and so on).

              Processes that are not dumpable can not be attached via [1mptrace[22m(2) [1mPTRACE_ATTACH[22m.

       [1mPR_GET_DUMPABLE [22m(since Linux 2.3.20)
              Return (as the function result) the current state of the calling process's dumpable flag.

       [1mPR_SET_ENDIAN [22m(since Linux 2.6.18, PowerPC only)
              Set the endian-ness of the calling process to the value given in [4marg2[24m, which should be one of  the
              following:   [1mPR_ENDIAN_BIG[22m,  [1mPR_ENDIAN_LITTLE[22m,  or  [1mPR_ENDIAN_PPC_LITTLE  [22m(PowerPC  pseudo  little
              endian).

       [1mPR_GET_ENDIAN [22m(since Linux 2.6.18, PowerPC only)
              Return the endian-ness of the calling process, in the location pointed to by [4m(int[24m [4m*)[24m [4marg2[24m.

       [1mPR_SET_FPEMU [22m(since Linux 2.4.18, 2.5.9, only on ia64)
              Set floating-point emulation control bits to [4marg2[24m.   Pass  [1mPR_FPEMU_NOPRINT  [22mto  silently  emulate
              floating-point operation accesses, or [1mPR_FPEMU_SIGFPE [22mto not emulate floating-point operations and
              send [1mSIGFPE [22minstead.

       [1mPR_GET_FPEMU [22m(since Linux 2.4.18, 2.5.9, only on ia64)
              Return floating-point emulation control bits, in the location pointed to by [4m(int[24m [4m*)[24m [4marg2[24m.

       [1mPR_SET_FPEXC [22m(since Linux 2.4.21, 2.5.32, only on PowerPC)
              Set floating-point exception mode to [4marg2[24m.  Pass [1mPR_FP_EXC_SW_ENABLE [22mto use FPEXC for FP exception
              enables,  [1mPR_FP_EXC_DIV  [22mfor floating-point divide by zero, [1mPR_FP_EXC_OVF [22mfor floating-point over‚Äê
              flow, [1mPR_FP_EXC_UND [22mfor floating-point underflow, [1mPR_FP_EXC_RES [22mfor floating-point inexact result,
              [1mPR_FP_EXC_INV [22mfor floating-point invalid operation, [1mPR_FP_EXC_DISABLED [22mfor FP exceptions disabled,
              [1mPR_FP_EXC_NONRECOV [22mfor async nonrecoverable exception mode, [1mPR_FP_EXC_ASYNC [22mfor async  recoverable
              exception mode, [1mPR_FP_EXC_PRECISE [22mfor precise exception mode.

       [1mPR_GET_FPEXC [22m(since Linux 2.4.21, 2.5.32, only on PowerPC)
              Return floating-point exception mode, in the location pointed to by [4m(int[24m [4m*)[24m [4marg2[24m.

       [1mPR_SET_KEEPCAPS [22m(since Linux 2.2.18)
              Set the state of the thread's "keep capabilities" flag, which determines whether the thread's per‚Äê
              mitted capability set is cleared when a change is made to the thread's  user  IDs  such  that  the
              thread's  real  UID,  effective UID, and saved set-user-ID all become nonzero when at least one of
              them previously had the value 0.  By default, the permitted capability set is cleared when such  a
              change is made; setting the "keep capabilities" flag prevents it from being cleared.  [4marg2[24m must be
              either 0 (permitted capabilities are cleared) or 1 (permitted capabilities are kept).  (A thread's
              [4meffective[24m  capability  set  is always cleared when such a credential change is made, regardless of
              the setting of the "keep capabilities" flag.)  The "keep capabilities" value will be reset to 0 on
              subsequent calls to [1mexecve[22m(2).

       [1mPR_GET_KEEPCAPS [22m(since Linux 2.2.18)
              Return  (as  the  function  result)  the current state of the calling thread's "keep capabilities"
              flag.

       [1mPR_MCE_KILL [22m(since Linux 2.6.32)
              Set the machine check  memory  corruption  kill  policy  for  the  current  thread.   If  [4marg2[24m  is
              [1mPR_MCE_KILL_CLEAR[22m, clear the thread memory corruption kill policy and use the system-wide default.
              (The system-wide default is defined by [4m/proc/sys/vm/memory_failure_early_kill[24m; see  [1mproc[22m(5).)   If
              [4marg2[24m  is [1mPR_MCE_KILL_SET[22m, use a thread-specific memory corruption kill policy.  In this case, [4marg3[0m
              defines whether the policy is [4mearly[24m [4mkill[24m ([1mPR_MCE_KILL_EARLY[22m), [4mlate[24m [4mkill[24m ([1mPR_MCE_KILL_LATE[22m), or the
              system-wide  default  ([1mPR_MCE_KILL_DEFAULT[22m).   Early  kill means that the thread receives a [1mSIGBUS[0m
              signal as soon as hardware memory corruption is detected inside its address space.  In  late  kill
              mode,  the  process  is  killed only when it accesses a corrupted page.  See [1msigaction[22m(2) for more
              information on the [1mSIGBUS [22msignal.  The policy is inherited  by  children.   The  remaining  unused
              [1mprctl[22m() arguments must be zero for future compatibility.

       [1mPR_MCE_KILL_GET [22m(since Linux 2.6.32)
              Return  the  current  per-process machine check kill policy.  All unused [1mprctl[22m() arguments must be
              zero.

       [1mPR_SET_MM [22m(since Linux 3.3)
              Modify certain kernel memory map descriptor fields of the calling process.  Usually  these  fields
              are  set by the kernel and dynamic loader (see [1mld.so[22m(8) for more information) and a regular appli‚Äê
              cation should not use this feature.  However, there are cases, such  as  self-modifying  programs,
              where a program might find it useful to change its own memory map.  This feature is available only
              if the kernel is built with the [1mCONFIG_CHECKPOINT_RESTORE [22moption  enabled.   The  calling  process
              must  have  the [1mCAP_SYS_RESOURCE [22mcapability.  The value in [4marg2[24m is one of the options below, while
              [4marg3[24m provides a new value for the option.

              [1mPR_SET_MM_START_CODE[0m
                     Set the address above which the program text can run.  The corresponding memory  area  must
                     be  readable  and executable, but not writable or sharable (see [1mmprotect[22m(2) and [1mmmap[22m(2) for
                     more information).

              [1mPR_SET_MM_END_CODE[0m
                     Set the address below which the program text can run.  The corresponding memory  area  must
                     be readable and executable, but not writable or sharable.

              [1mPR_SET_MM_START_DATA[0m
                     Set  the address above which initialized and uninitialized (bss) data are placed.  The cor‚Äê
                     responding memory area must be readable and writable, but not executable or sharable.

              [1mPR_SET_MM_END_DATA[0m
                     Set the address below which initialized and uninitialized (bss) data are placed.  The  cor‚Äê
                     responding memory area must be readable and writable, but not executable or sharable.

              [1mPR_SET_MM_START_STACK[0m
                     Set  the  start  address  of the stack.  The corresponding memory area must be readable and
                     writable.

              [1mPR_SET_MM_START_BRK[0m
                     Set the address above which the program heap can be expanded with [1mbrk[22m(2) call.  The address
                     must  be greater than the ending address of the current program data segment.  In addition,
                     the combined size of the resulting heap and the size of the data segment can't  exceed  the
                     [1mRLIMIT_DATA [22mresource limit (see [1msetrlimit[22m(2)).

              [1mPR_SET_MM_BRK[0m
                     Set  the  current  [1mbrk[22m(2)  value.  The requirements for the address are the same as for the
                     [1mPR_SET_MM_START_BRK [22moption.

              The following options are available since Linux 3.5.

              [1mPR_SET_MM_ARG_START[0m
                     Set the address above which the program command line is placed.

              [1mPR_SET_MM_ARG_END[0m
                     Set the address below which the program command line is placed.

              [1mPR_SET_MM_ENV_START[0m
                     Set the address above which the program environment is placed.

              [1mPR_SET_MM_ENV_END[0m
                     Set the address below which the program environment is placed.

                     The address passed with [1mPR_SET_MM_ARG_START[22m,  [1mPR_SET_MM_ARG_END[22m,  [1mPR_SET_MM_ENV_START[22m,  and
                     [1mPR_SET_MM_ENV_END  [22mshould  belong  to a process stack area.  Thus, the corresponding memory
                     area must be readable, writable, and (depending  on  the  kernel  configuration)  have  the
                     [1mMAP_GROWSDOWN [22mattribute set (see [1mmmap[22m(2)).

              [1mPR_SET_MM_AUXV[0m
                     Set  a  new  auxiliary vector.  The [4marg3[24m argument should provide the address of the vector.
                     The [4marg4[24m is the size of the vector.

              [1mPR_SET_MM_EXE_FILE[0m
                     Supersede the [4m/proc/pid/exe[24m symbolic link with a new one pointing to a new executable  file
                     identified by the file descriptor provided in [4marg3[24m argument.  The file descriptor should be
                     obtained with a regular [1mopen[22m(2) call.

                     To change the symbolic link, one needs to  unmap  all  existing  executable  memory  areas,
                     including  those  created  by  the kernel itself (for example the kernel usually creates at
                     least one executable memory area for the ELF [4m.text[24m section).

                     The second limitation is that such transitions can be done only  once  in  a  process  life
                     time.  Any further attempts will be rejected.  This should help system administrators moni‚Äê
                     tor unusual symbolic-link transitions over all processes running on a system.

       [1mPR_MPX_ENABLE_MANAGEMENT[22m, [1mPR_MPX_DISABLE_MANAGEMENT [22m(since Linux 3.19)
              Enable or disable kernel management of Memory Protection  eXtensions  (MPX)  bounds  tables.   The
              [4marg2[24m, [4marg3[24m, [4marg4[24m, and [4marg5[24m arguments must be zero.

              MPX is a hardware-assisted mechanism for performing bounds checking on pointers.  It consists of a
              set of registers storing bounds information and a set of special instruction  prefixes  that  tell
              the CPU on which instructions it should do bounds enforcement.  There is a limited number of these
              registers and when there are more pointers than registers, their contents must be "spilled" into a
              set  of  tables.   These  tables are called "bounds tables" and the MPX [1mprctl[22m() operations control
              whether the kernel manages their allocation and freeing.

              When management is enabled, the kernel will take over allocation and freeing of the bounds tables.
              It  does this by trapping the #BR exceptions that result at first use of missing bounds tables and
              instead of delivering the exception to user space, it allocates the table and populates the bounds
              directory  with  the  location  of the new table.  For freeing, the kernel checks to see if bounds
              tables are present for memory which is not allocated, and frees them if so.

              Before enabling MPX management using [1mPR_MPX_ENABLE_MANAGEMENT[22m, the  application  must  first  have
              allocated  a  user-space buffer for the bounds directory and placed the location of that directory
              in the [4mbndcfgu[24m register.

              These calls will fail if the CPU or kernel does not  support  MPX.   Kernel  support  for  MPX  is
              enabled via the [1mCONFIG_X86_INTEL_MPX [22mconfiguration option.  You can check whether the CPU supports
              MPX by looking for the 'mpx' CPUID bit, like with the following command:

                   cat /proc/cpuinfo | grep ' mpx '

              A thread may not switch in or out of long (64-bit) mode while MPX is enabled.

              All threads in a process are affected by these calls.

              The child of a [1mfork[22m(2) inherits the state of MPX management.  During [1mexecve[22m(2), MPX management  is
              reset to a state as if [1mPR_MPX_DISABLE_MANAGEMENT [22mhad been called.

              For further information on Intel MPX, see the kernel source file [4mDocumentation/x86/intel_mpx.txt[24m.

       [1mPR_SET_NAME [22m(since Linux 2.6.9)
              Set  the  name of the calling thread, using the value in the location pointed to by [4m(char[24m [4m*)[24m [4marg2[24m.
              The name can be up to 16 bytes long, including the terminating null byte.  (If the length  of  the
              string,  including the terminating null byte, exceeds 16 bytes, the string is silently truncated.)
              This is the same  attribute  that  can  be  set  via  [1mpthread_setname_np[22m(3)  and  retrieved  using
              [1mpthread_getname_np[22m(3).  The attribute is likewise accessible via [4m/proc/self/task/[tid]/comm[24m, where
              [4mtid[24m is the name of the calling thread.

       [1mPR_GET_NAME [22m(since Linux 2.6.11)
              Return the name of the calling thread, in the buffer pointed to  by  [4m(char[24m [4m*)[24m  [4marg2[24m.   The  buffer
              should allow space for up to 16 bytes; the returned string will be null-terminated.

       [1mPR_SET_NO_NEW_PRIVS [22m(since Linux 3.5)
              Set  the  calling  process's  [4mno_new_privs[24m  bit to the value in [4marg2[24m.  With [4mno_new_privs[24m set to 1,
              [1mexecve[22m(2) promises not to grant privileges to do anything that could not have  been  done  without
              the  [1mexecve[22m(2)  call  (for example, rendering the set-user-ID and set-group-ID mode bits, and file
              capabilities non-functional).  Once set, this bit cannot be unset.  The setting  of  this  bit  is
              inherited by children created by [1mfork[22m(2) and [1mclone[22m(2), and preserved across [1mexecve[22m(2).

              For more information, see the kernel source file [4mDocumentation/prctl/no_new_privs.txt[24m.

       [1mPR_GET_NO_NEW_PRIVS [22m(since Linux 3.5)
              Return  (as  the  function  result)  the value of the [4mno_new_privs[24m bit for the current process.  A
              value of 0 indicates the regular [1mexecve[22m(2) behavior.  A value of 1 indicates [1mexecve[22m(2) will  oper‚Äê
              ate in the privilege-restricting mode described above.

       [1mPR_SET_PDEATHSIG [22m(since Linux 2.1.57)
              Set  the  parent  death  signal of the calling process to [4marg2[24m (either a signal value in the range
              1..maxsig, or 0 to clear).  This is the signal that the calling process will get when  its  parent
              dies.   This  value  is  cleared for the child of a [1mfork[22m(2) and (since Linux 2.4.36 / 2.6.23) when
              executing a set-user-ID or set-group-ID binary, or a binary that has associated capabilities  (see
              [1mcapabilities[22m(7)).  This value is preserved across [1mexecve[22m(2).

              [4mWarning[24m:  the  "parent" in this case is considered to be the [4mthread[24m that created this process.  In
              other  words,  the  signal  will  be  sent  when  that  thread  terminates  (via,   for   example,
              [1mpthread_exit[22m(3)), rather than after all of the threads in the parent process terminate.

       [1mPR_GET_PDEATHSIG [22m(since Linux 2.3.15)
              Return the current value of the parent process death signal, in the location pointed to by [4m(int[24m [4m*)[0m
              [4marg2[24m.

       [1mPR_SET_PTRACER [22m(since Linux 3.4)
              This is meaningful only when the Yama LSM is enabled and in mode 1 ("restricted  ptrace",  visible
              via [4m/proc/sys/kernel/yama/ptrace_scope[24m).  When a "ptracer process ID" is passed in [4marg2[24m, the call‚Äê
              er is declaring that the ptracer process can [1mptrace[22m(2) the calling process as if it were a  direct
              process  ancestor.   Each  [1mPR_SET_PTRACER  [22moperation  replaces  the previous "ptracer process ID".
              Employing [1mPR_SET_PTRACER [22mwith [4marg2[24m set to 0 clears the caller's "ptracer process ID".  If [4marg2[24m  is
              [1mPR_SET_PTRACER_ANY[22m,  the  ptrace  restrictions introduced by Yama are effectively disabled for the
              calling process.

              For further information, see the kernel source file [4mDocumentation/security/Yama.txt[24m.

       [1mPR_SET_SECCOMP [22m(since Linux 2.6.23)
              Set the secure computing (seccomp) mode for the calling thread,  to  limit  the  available  system
              calls.   The  more  recent  [1mseccomp[22m(2)  system  call  provides  a superset of the functionality of
              [1mPR_SET_SECCOMP[22m.

              The seccomp mode is selected via [4marg2[24m.  (The seccomp constants are defined in [4m<linux/seccomp.h>[24m.)

              With [4marg2[24m set to [1mSECCOMP_MODE_STRICT[22m, the only system calls that the thread is permitted  to  make
              are  [1mread[22m(2),  [1mwrite[22m(2),  [1m_exit[22m(2)  (but not [1mexit_group[22m(2)), and [1msigreturn[22m(2).  Other system calls
              result in the delivery of a [1mSIGKILL [22msignal.  Strict secure computing mode is  useful  for  number-
              crunching  applications  that may need to execute untrusted byte code, perhaps obtained by reading
              from a pipe or socket.  This operation is available only if the kernel  is  configured  with  [1mCON‚Äê[0m
              [1mFIG_SECCOMP [22menabled.

              With  [4marg2[24m set to [1mSECCOMP_MODE_FILTER [22m(since Linux 3.5), the system calls allowed are defined by a
              pointer to a Berkeley Packet Filter passed  in  [4marg3[24m.   This  argument  is  a  pointer  to  [4mstruct[0m
              [4msock_fprog[24m;  it  can be designed to filter arbitrary system calls and system call arguments.  This
              mode is available only if the kernel is configured with [1mCONFIG_SECCOMP_FILTER [22menabled.

              If [1mSECCOMP_MODE_FILTER [22mfilters permit [1mfork[22m(2), then the seccomp mode is inherited by children cre‚Äê
              ated  by  [1mfork[22m(2); if [1mexecve[22m(2) is permitted, then the seccomp mode is preserved across [1mexecve[22m(2).
              If the filters permit [1mprctl[22m() calls, then additional filters can be added; they are run  in  order
              until the first non-allow result is seen.

              For further information, see the kernel source file [4mDocumentation/prctl/seccomp_filter.txt[24m.

       [1mPR_GET_SECCOMP [22m(since Linux 2.6.23)
              Return (as the function result) the secure computing mode of the calling thread.  If the caller is
              not in secure computing mode, this operation returns 0; if the caller is in strict secure  comput‚Äê
              ing  mode,  then  the  [1mprctl[22m() call will cause a [1mSIGKILL [22msignal to be sent to the process.  If the
              caller is in filter mode, and this system call is allowed by the seccomp filters,  it  returns  2;
              otherwise,  the  process is killed with a [1mSIGKILL [22msignal.  This operation is available only if the
              kernel is configured with [1mCONFIG_SECCOMP [22menabled.

              Since Linux 3.8, the [4mSeccomp[24m field of the [4m/proc/[pid]/status[24m file provides a method  of  obtaining
              the same information, without the risk that the process is killed; see [1mproc[22m(5).

       [1mPR_SET_SECUREBITS [22m(since Linux 2.6.26)
              Set  the  "securebits"  flags  of the calling thread to the value supplied in [4marg2[24m.  See [1mcapabili‚Äê[0m
              [1mties[22m(7).

       [1mPR_GET_SECUREBITS [22m(since Linux 2.6.26)
              Return (as the function result) the "securebits" flags  of  the  calling  thread.   See  [1mcapabili‚Äê[0m
              [1mties[22m(7).

       [1mPR_SET_THP_DISABLE [22m(since Linux 3.15)
              Set  the state of the "THP disable" flag for the calling thread.  If [4marg2[24m has a nonzero value, the
              flag is set, otherwise it is cleared.  Setting this flag provides a method for disabling transpar‚Äê
              ent huge pages for jobs where the code cannot be modified, and using a malloc hook with [1mmadvise[22m(2)
              is not an option (i.e., statically allocated data).  The setting of  the  "THP  disable"  flag  is
              inherited by a child created via [1mfork[22m(2) and is preserved across [1mexecve[22m(2).

       [1mPR_TASK_PERF_EVENTS_DISABLE [22m(since Linux 2.6.31)
              Disable  all performance counters attached to the calling process, regardless of whether the coun‚Äê
              ters were created by this process or another process.  Performance counters created by the calling
              process for other processes are unaffected.  For more information on performance counters, see the
              Linux kernel source file [4mtools/perf/design.txt[24m.

              Originally called [1mPR_TASK_PERF_COUNTERS_DISABLE[22m; renamed (with  same  numerical  value)  in  Linux
              2.6.32.

       [1mPR_TASK_PERF_EVENTS_ENABLE [22m(since Linux 2.6.31)
              The  converse  of [1mPR_TASK_PERF_EVENTS_DISABLE[22m; enable performance counters attached to the calling
              process.

              Originally called [1mPR_TASK_PERF_COUNTERS_ENABLE[22m; renamed in Linux 2.6.32.

       [1mPR_GET_THP_DISABLE [22m(since Linux 3.15)
              Return (via the function result) the current setting of the "THP disable"  flag  for  the  calling
              thread: either 1, if the flag is set, or 0, if it is not.

       [1mPR_GET_TID_ADDRESS [22m(since Linux 3.5)
              Retrieve    the   [4mclear_child_tid[24m   address   set   by   [1mset_tid_address[22m(2)   and   the   [1mclone[22m(2)
              [1mCLONE_CHILD_CLEARTID [22mflag, in the location pointed to by [4m(int[24m [4m**)[24m [4marg2[24m.  This feature is available
              only if the kernel is built with the [1mCONFIG_CHECKPOINT_RESTORE [22moption enabled.

       [1mPR_SET_TIMERSLACK [22m(since Linux 2.6.28)
              Set  the  current timer slack for the calling thread to the nanosecond value supplied in [4marg2[24m.  If
              [4marg2[24m is less than or equal to zero, reset the current timer slack to the  thread's  default  timer
              slack  value.   The  timer  slack is used by the kernel to group timer expirations for the calling
              thread that are close to one another; as a consequence, timer expirations for the thread may be up
              to the specified number of nanoseconds late (but will never expire early).  Grouping timer expira‚Äê
              tions can help reduce system power consumption by minimizing CPU wake-ups.

              The timer expirations affected by timer slack are those set  by  [1mselect[22m(2),  [1mpselect[22m(2),  [1mpoll[22m(2),
              [1mppoll[22m(2),  [1mepoll_wait[22m(2), [1mepoll_pwait[22m(2), [1mclock_nanosleep[22m(2), [1mnanosleep[22m(2), and [1mfutex[22m(2) (and thus
              the   library   functions   implemented   via   futexes,   including    [1mpthread_cond_timedwait[22m(3),
              [1mpthread_mutex_timedlock[22m(3),   [1mpthread_rwlock_timedrdlock[22m(3),   [1mpthread_rwlock_timedwrlock[22m(3),  and
              [1msem_timedwait[22m(3)).

              Timer slack is not applied to threads that are scheduled under a real-time scheduling policy  (see
              [1msched_setscheduler[22m(2)).

              Each  thread has two associated timer slack values: a "default" value, and a "current" value.  The
              current value is the one that governs grouping of timer expirations.  When a new  thread  is  cre‚Äê
              ated,  the  two  timer slack values are made the same as the current value of the creating thread.
              Thereafter, a thread can adjust its current timer slack value via [1mPR_SET_TIMERSLACK  [22m(the  default
              value  can't  be changed).  The timer slack values of [4minit[24m (PID 1), the ancestor of all processes,
              are 50,000 nanoseconds (50 microseconds).  The timer slack values are preserved across [1mexecve[22m(2).

       [1mPR_GET_TIMERSLACK [22m(since Linux 2.6.28)
              Return (as the function result) the current timer slack value of the calling thread.

       [1mPR_SET_TIMING [22m(since Linux 2.6.0-test4)
              Set whether to use (normal, traditional) statistical process timing  or  accurate  timestamp-based
              process  timing, by passing [1mPR_TIMING_STATISTICAL [22mor [1mPR_TIMING_TIMESTAMP [22mto [4marg2[24m.  [1mPR_TIMING_TIME‚Äê[0m
              [1mSTAMP [22mis not currently implemented (attempting to set this mode will yield the error [1mEINVAL[22m).

       [1mPR_GET_TIMING [22m(since Linux 2.6.0-test4)
              Return (as the function result) which process timing method is currently in use.

       [1mPR_SET_TSC [22m(since Linux 2.6.26, x86 only)
              Set the state of the flag determining whether the timestamp counter can be read  by  the  process.
              Pass  [1mPR_TSC_ENABLE  [22mto  [4marg2[24m to allow it to be read, or [1mPR_TSC_SIGSEGV [22mto generate a [1mSIGSEGV [22mwhen
              the process tries to read the timestamp counter.

       [1mPR_GET_TSC [22m(since Linux 2.6.26, x86 only)
              Return the state of the flag determining whether the timestamp counter can be read, in  the  loca‚Äê
              tion pointed to by [4m(int[24m [4m*)[24m [4marg2[24m.

       [1mPR_SET_UNALIGN[0m
              (Only  on:  ia64,  since  Linux  2.3.48;  parisc, since Linux 2.6.15; PowerPC, since Linux 2.6.18;
              Alpha, since Linux 2.6.22) Set unaligned access control bits to [4marg2[24m.  Pass [1mPR_UNALIGN_NOPRINT  [22mto
              silently fix up unaligned user accesses, or [1mPR_UNALIGN_SIGBUS [22mto generate [1mSIGBUS [22mon unaligned user
              access.

       [1mPR_GET_UNALIGN[0m
              (see [1mPR_SET_UNALIGN [22mfor information on versions and architectures) Return unaligned access control
              bits, in the location pointed to by [4m(int[24m [4m*)[24m [4marg2[24m.

[1mRETURN VALUE[0m
       On  success,  [1mPR_GET_DUMPABLE[22m, [1mPR_GET_KEEPCAPS[22m, [1mPR_GET_NO_NEW_PRIVS[22m, [1mPR_GET_THP_DISABLE[22m, [1mPR_CAPBSET_READ[22m,
       [1mPR_GET_TIMING[22m,   [1mPR_GET_TIMERSLACK[22m,   [1mPR_GET_SECUREBITS[22m,   [1mPR_MCE_KILL_GET[22m,   [1mPR_CAP_AMBIENT[22m+[1mPR_CAP_AMBI‚Äê[0m
       [1mENT_IS_SET[22m,  and (if it returns) [1mPR_GET_SECCOMP [22mreturn the nonnegative values described above.  All other
       [4moption[24m values return 0 on success.  On error, -1 is returned, and [4merrno[24m is set appropriately.

[1mERRORS[0m
       [1mEACCES [4m[22moption[24m is [1mPR_SET_MM[22m, and [4marg3[24m is [1mPR_SET_MM_EXE_FILE[22m, the file is not executable.

       [1mEBADF  [4m[22moption[24m is [1mPR_SET_MM[22m, [4marg3[24m is [1mPR_SET_MM_EXE_FILE[22m, and the file descriptor passed  in  [4marg4[24m  is  not
              valid.

       [1mEBUSY  [4m[22moption[24m  is  [1mPR_SET_MM[22m,  [4marg3[24m  is  [1mPR_SET_MM_EXE_FILE[22m,  and  this  the second attempt to change the
              [4m/proc/pid/exe[24m symbolic link, which is prohibited.

       [1mEFAULT [4m[22marg2[24m is an invalid address.

       [1mEFAULT [4m[22moption[24m is [1mPR_SET_SECCOMP[22m, [4marg2[24m is [1mSECCOMP_MODE_FILTER[22m,  the  system  was  built  with  [1mCONFIG_SEC‚Äê[0m
              [1mCOMP_FILTER[22m, and [4marg3[24m is an invalid address.

       [1mEINVAL [22mThe value of [4moption[24m is not recognized.

       [1mEINVAL [4m[22moption[24m is [1mPR_MCE_KILL [22mor [1mPR_MCE_KILL_GET [22mor [1mPR_SET_MM[22m, and unused [1mprctl[22m() arguments were not spec‚Äê
              ified as zero.

       [1mEINVAL [4m[22marg2[24m is not valid value for this [4moption[24m.

       [1mEINVAL [4m[22moption[24m is [1mPR_SET_SECCOMP [22mor [1mPR_GET_SECCOMP[22m, and the kernel was not configured with [1mCONFIG_SECCOMP[22m.

       [1mEINVAL [4m[22moption[24m is [1mPR_SET_SECCOMP[22m, [4marg2[24m is [1mSECCOMP_MODE_FILTER[22m, and the kernel was not configured with [1mCON‚Äê[0m
              [1mFIG_SECCOMP_FILTER[22m.

       [1mEINVAL [4m[22moption[24m is [1mPR_SET_MM[22m, and one of the following is true

              *  [4marg4[24m or [4marg5[24m is nonzero;

              *  [4marg3[24m is greater than [1mTASK_SIZE [22m(the limit on the size of the user address space for this archi‚Äê
                 tecture);

              *  [4marg2[24m is [1mPR_SET_MM_START_CODE[22m, [1mPR_SET_MM_END_CODE[22m, [1mPR_SET_MM_START_DATA[22m, [1mPR_SET_MM_END_DATA[22m,  or
                 [1mPR_SET_MM_START_STACK[22m,  and  the  permissions  of  the  corresponding  memory  area  are not as
                 required;

              *  [4marg2[24m is [1mPR_SET_MM_START_BRK [22mor [1mPR_SET_MM_BRK[22m, and [4marg3[24m is less than or equal to the end of  the
                 data  segment  or  specifies  a  value  that  would  cause the [1mRLIMIT_DATA [22mresource limit to be
                 exceeded.

       [1mEINVAL [4m[22moption[24m is [1mPR_SET_PTRACER [22mand [4marg2[24m is not 0, [1mPR_SET_PTRACER_ANY[22m, or the PID of an existing process.

       [1mEINVAL [4m[22moption[24m is [1mPR_SET_PDEATHSIG [22mand [4marg2[24m is not a valid signal number.

       [1mEINVAL [4m[22moption[24m is [1mPR_SET_DUMPABLE [22mand [4marg2[24m is neither [1mSUID_DUMP_DISABLE [22mnor [1mSUID_DUMP_USER[22m.

       [1mEINVAL [4m[22moption[24m is [1mPR_SET_TIMING [22mand [4marg2[24m is not [1mPR_TIMING_STATISTICAL[22m.

       [1mEINVAL [4m[22moption[24m is [1mPR_SET_NO_NEW_PRIVS [22mand [4marg2[24m is not equal to 1 or [4marg3[24m, [4marg4[24m, or [4marg5[24m is nonzero.

       [1mEINVAL [4m[22moption[24m is [1mPR_GET_NO_NEW_PRIVS [22mand [4marg2[24m, [4marg3[24m, [4marg4[24m, or [4marg5[24m is nonzero.

       [1mEINVAL [4m[22moption[24m is [1mPR_SET_THP_DISABLE [22mand [4marg3[24m, [4marg4[24m, or [4marg5[24m is nonzero.

       [1mEINVAL [4m[22moption[24m is [1mPR_GET_THP_DISABLE [22mand [4marg2[24m, [4marg3[24m, [4marg4[24m, or [4marg5[24m is nonzero.

       [1mEINVAL [4m[22moption[24m is [1mPR_CAP_AMBIENT [22mand an unused argument ([4marg4[24m, [4marg5[24m,  or,  in  the  case  of  [1mPR_CAP_AMBI‚Äê[0m
              [1mENT_CLEAR_ALL[22m,  [4marg3[24m)  is  nonzero; or [4marg2[24m has an invalid value; or [4marg2[24m is [1mPR_CAP_AMBIENT_LOWER[22m,
              [1mPR_CAP_AMBIENT_RAISE[22m, or [1mPR_CAP_AMBIENT_IS_SET [22mand [4marg3[24m does not specify a valid capability.

       [1mENXIO  [4m[22moption[24m was [1mPR_MPX_ENABLE_MANAGEMENT [22mor [1mPR_MPX_DISABLE_MANAGEMENT [22mand the kernel or  the  CPU  does
              not support MPX management.  Check that the kernel and processor have MPX support.

       [1mEPERM  [4m[22moption[24m  is [1mPR_SET_SECUREBITS[22m, and the caller does not have the [1mCAP_SETPCAP [22mcapability, or tried to
              unset a "locked" flag, or tried to set a flag whose corresponding locked flag was set  (see  [1mcapa‚Äê[0m
              [1mbilities[22m(7)).

       [1mEPERM  [4m[22moption[24m  is  [1mPR_SET_KEEPCAPS[22m,  and  the caller's [1mSECURE_KEEP_CAPS_LOCKED [22mflag is set (see [1mcapabili‚Äê[0m
              [1mties[22m(7)).

       [1mEPERM  [4m[22moption[24m is [1mPR_CAPBSET_DROP[22m, and the caller does not have the [1mCAP_SETPCAP [22mcapability.

       [1mEPERM  [4m[22moption[24m is [1mPR_SET_MM[22m, and the caller does not have the [1mCAP_SYS_RESOURCE [22mcapability.

       [1mEPERM  [4m[22moption[24m is [1mPR_CAP_AMBIENT [22mand [4marg2[24m is [1mPR_CAP_AMBIENT_RAISE[22m, but either the capability specified  in
              [4marg3[24m  is  not  present  in  the  process's  permitted  and  inheritable  capability  sets,  or the
              [1mPR_CAP_AMBIENT_LOWER [22msecurebit has been set.

[1mVERSIONS[0m
       The [1mprctl[22m() system call was introduced in Linux 2.1.57.

[1mCONFORMING TO[0m
       This call is Linux-specific.  IRIX has a  [1mprctl[22m()  system  call  (also  introduced  in  Linux  2.1.44  as
       irix_prctl on the MIPS architecture), with prototype

       [1mptrdiff_t prctl(int [4m[22moption[24m[1m, int [4m[22marg2[24m[1m, int [4m[22marg3[24m[1m);[0m

       and  options  to  get  the maximum number of processes per user, get the maximum number of processors the
       calling process can use, find out whether a specified process is currently blocked, get or set the  maxi‚Äê
       mum stack size, and so on.

[1mSEE ALSO[0m
       [1msignal[22m(2), [1mcore[22m(5)

[1mCOLOPHON[0m
       This page is part of release 4.06 of the Linux [4mman-pages[24m project.  A description of the project, informa‚Äê
       tion  about  reporting   bugs,   and   the   latest   version   of   this   page,   can   be   found   at
       https://www.kernel.org/doc/man-pages/.

Linux                                              2015-12-05                                           PRCTL(2)
